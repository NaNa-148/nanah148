<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>ספר המידות</title>
    <style>
        body {
            margin: 0;
            padding: 60px 5%;
            min-height: 100vh;
            background: linear-gradient(to bottom right, #0b1e2f, #1a2e4f);
            color: white;
            font-family: 'Arial', 'Narkis Block', 'David Libre', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-sizing: border-box;
            overflow-x: hidden;
            overflow-y: auto;
        }
        .top-bar {
            position: fixed;
            top: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            box-sizing: border-box;
            z-index: 999;
            flex-wrap: wrap;
        }

        body.fullscreen-active .top-bar {
            display: none !important;
        }

        .controls-container {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .top-text, .control-element {
            font-size: 16px;
            opacity: 0.9;
            background: rgba(255, 255, 255, 0.15);
            padding: 8px 12px;
            border-radius: 5px;
            color: white;
            border: none;
            cursor: pointer;
        }
        .control-element select {
             background: transparent;
             color: white;
             border: none;
             padding: 2px;
        }
        .control-element option {
            background: #1a2e4f;
            color: white;
        }

        .content-display {
            max-width: 800px;
            width: 90%;
        }
        .topic-display, .letter-display, .text-display {
            margin-bottom: 15px;
            transition: opacity 0.5s ease-in-out;
        }
        .topic-display {
            font-size: calc(2.2em + 30px);
            font-weight: bold;
            color: white;
        }
        .letter-display {
            font-size: calc(1.8em + 10px);
            color: white;
        }
        .text-display {
            font-size: calc(1.6em + 10px);
            line-height: 1.8;
            min-height: 100px;
            color: white;
        }

        .nanach-signature {
            position: fixed;
            bottom: 15px;
            right: 15px;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            white-space: nowrap;
            font-family: 'David Libre', 'Narkis Block', serif;
            z-index: 1001;
        }

        .nanach-signature span {
            opacity: 0;
            animation: fadeIn依次 1s forwards;
        }

        .nanach-signature .s1 { color: white; animation-delay: 0.5s; }
        .nanach-signature .s2 { color: #FFD700; animation-delay: 1.0s; margin-right: 0.7em; }
        .nanach-signature .s3 { color: #FF7F50; animation-delay: 1.5s; margin-right: 0.7em; }
        .nanach-signature .s4 { color: #87CEEB; animation-delay: 2.0s; margin-right: 0.7em; }
        .nanach-signature .s5 {
            animation-delay: 2.5s; margin-right: 0.7em;
        }
        .nanach-signature .s5 .char1 { color: #FFDAB9; }
        .nanach-signature .s5 .char2 { color: #FFFF00; }
        .nanach-signature .s5 .char3 { color: #EE82EE; }
        .nanach-signature .s5 .char4 { color: #98FB98; }
        .nanach-signature .s5 .char5 { color: #AFEEEE; }

        @keyframes fadeIn依次 {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* QR Code Styling */
        #qr-code-container {
            position: fixed;
            bottom: 15px;
            left: 15px;
            width: 100px; 
            height: 100px;
            z-index: 1002; 
            opacity: 0.85;
        }
        #qr-code-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }


        @media (max-width: 600px) {
            .top-bar:not(body.fullscreen-active .top-bar) {
                flex-direction: column;
                align-items: center;
            }
            .controls-container {
                margin-top:10px;
                justify-content: center;
            }
            .topic-display { font-size: calc(1.8em + 30px); }
            .letter-display { font-size: calc(1.5em + 10px); }
            .text-display { font-size: calc(1.3em + 10px); }
            body { padding: 80px 5% 60px 5%; }
            .nanach-signature { font-size: 20px; bottom: 10px; right: 10px; }
            #qr-code-container { /* QR code adjustments for smaller screens */
                width: 70px;
                height: 70px;
                bottom: 10px;
                left: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="controls-container">
            <button id="prev-btn" class="control-element top-text">הקודם</button>
            <button id="next-btn" class="control-element top-text">הבא</button>
            <button id="random-toggle" class="control-element top-text">סדר: רגיל</button>
            <div class="control-element">
                <label for="timing-select">זמן: </label>
                <select id="timing-select" onchange="updateInterval()">
                    <option value="3000">3 שניות</option>
                    <option value="5000">5 שניות</option>
                    <option value="7000" selected>7 שניות</option>
                    <option value="10000">10 שניות</option>
                    <option value="15000">15 שניות</option>
                    <option value="20000">20 שניות</option>
                    <option value="30000">30 שניות</option>
                    <option value="300000">5 דקות</option>
                    <option value="900000">15 דקות</option>
                    <option value="1800000">30 דקות</option>
                    <option value="3600000">1 שעה</option>
                    <option value="21600000">6 שעות</option>
                    <option value="43200000">12 שעות</option>
                    <option value="86400000">24 שעות</option>
                </select>
            </div>
             <div class="control-element">
                <label for="topic-select">נושא: </label>
                <select id="topic-select" onchange="handleTopicChange()">
                    <option value="all">כל הנושאים</option>
                </select>
            </div>
        </div>
        <button class="fullscreen-btn top-text" onclick="toggleFullScreen()">מסך מלא</button>
    </div>

    <div class="content-display">
        <div id="current-topic" class="topic-display">טוען נתונים...</div>
        <div id="current-letter" class="letter-display"></div>
        <div id="current-text" class="text-display"></div>
    </div>

    <div class="nanach-signature">
        <span class="s1">נ</span>
        <span class="s2">נח</span>
        <span class="s3">נחמ</span>
        <span class="s4">נחמן</span>
        <span class="s5">
            <span class="char1">מ</span><span class="char2">א</span><span class="char3">ו</span><span class="char4">מ</span><span class="char5">ן</span>
        </span>
    </div>

    <div id="qr-code-container">
        <img src="rabenoQR.png" alt="QR Code">
    </div>

    <script>
        let entries = [];
        let current = 0;
        let isRandom = false;
        let duration = 7000;
        let intervalId;
        let currentFilteredEntries = [];
        let currentSelectedTopic = "all";

        const topicElement = document.getElementById('current-topic');
        const letterElement = document.getElementById('current-letter');
        const textElement = document.getElementById('current-text');
        const randomToggleButton = document.getElementById('random-toggle');
        const topicSelectElement = document.getElementById('topic-select');
        const bodyElement = document.body;

        const HEBREW_LETTERS_TO_NUMBER = {
            'א': 1, 'ב': 2, 'ג': 3, 'ד': 4, 'ה': 5, 'ו': 6, 'ז': 7, 'ח': 8, 'ט': 9, 'י': 10,
            'כ': 20, 'ל': 30, 'מ': 40, 'נ': 50, 'ס': 60, 'ע': 70, 'פ': 80, 'צ': 90, 'ק': 100,
            'ר': 200, 'ש': 300, 'ת': 400, 'ך': 20, 'ם': 40, 'ן': 50, 'ף': 80, 'ץ': 90,
            'יא': 11, 'יב': 12, 'יג': 13, 'יד': 14, 'טו': 15, 'טז': 16, 'יז': 17, 'יח': 18, 'יט': 19,
            'כא': 21, 'כב': 22, 'כג': 23, 'כד': 24, 'כה': 25, 'כו': 26, 'כז': 27, 'כח': 28, 'כט': 29,
            'לא': 31, 'לב': 32, 'לג': 33, 'לד': 34, 'לה': 35, 'לו': 36, 'לז': 37, 'לח': 38, 'לט': 39,
            'מא': 41, 'מב': 42, 'מג': 43, 'מד': 44, 'מה': 45, 'מו': 46, 'מז': 47, 'מח': 48, 'מט': 49,
            'נא': 51, 'נב': 52, 'נג': 53, 'נד': 54, 'נה': 55, 'נו': 56, 'נז': 57, 'נח': 58, 'נט': 59,
            'סא': 61, 'סב': 62, 'סג': 63, 'סד': 64, 'סה': 65, 'סו': 66, 'סז': 67, 'סח': 68, 'סט': 69,
            'עא': 71, 'עב': 72, 'עג': 73, 'עד': 74, 'עה': 75, 'עו': 76, 'עז': 77, 'עח': 78, 'עט': 79,
             // הוסף כאן עוד צירופים לפי הצורך עד קצט
            'פא': 81, 'פב': 82, 'פג': 83, 'פד': 84, 'פה': 85, 'פו': 86, 'פז': 87, 'פח': 88, 'פט': 89,
            'צא': 91, 'צב': 92, 'צג': 93, 'צד': 94, 'צה': 95, 'צו': 96, 'צז': 97, 'צח': 98, 'צט': 99,
            'קא': 101, 'קב': 102, 'קג': 103, 'קד': 104, 'קה': 105, 'קו': 106, 'קז': 107, 'קח': 108, 'קט': 109,
            'קי': 110, 'קיא': 111, 'קיב': 112, 'קיג': 113, 'קיד': 114, 'קטו': 115, 'קטז': 116, 'קיז': 117, 'קיח': 118, 'קיט': 119,
            'קכ': 120, 'קכא': 121, 'קכב': 122, 'קכג': 123, 'קכד': 124, 'קכה': 125, 'קכו': 126, 'קכז': 127, 'קכח': 128, 'קכט': 129,
            'קל': 130, 'קלא': 131, 'קלב': 132, 'קלג': 133, 'קלד': 134, 'קלה': 135, 'קלו': 136, 'קלז': 137, 'קלח': 138, 'קלט': 139,
            'קמ': 140, 'קמא': 141, 'קמב': 142, 'קמג': 143, 'קמד': 144, 'קמה': 145, 'קמו': 146, 'קמז': 147, 'קמח': 148, 'קמט': 149,
            'קנ': 150, 'קנא': 151, 'קנב': 152, 'קנג': 153, 'קנד': 154, 'קנה': 155, 'קנו': 156, 'קנז': 157, 'קנח': 158, 'קנט': 159,
            'קס': 160, 'קסא': 161, 'קסב': 162, 'קסג': 163, 'קסד': 164, 'קסה': 165, 'קסו': 166, 'קסז': 167, 'קסח': 168, 'קסט': 169,
            'קע': 170, 'קעא': 171, 'קעב': 172, 'קעג': 173, 'קעד': 174, 'קעה': 175, 'קעו': 176, 'קעז': 177, 'קעח': 178, 'קעט': 179,
            'קפ': 180, 'קפא': 181, 'קפב': 182, 'קפג': 183, 'קפד': 184, 'קפה': 185, 'קפו': 186, 'קפז': 187, 'קפח': 188, 'קפט': 189,
            'קצ': 190, 'קצא': 191, 'קצב': 192, 'קצג': 193, 'קצד': 194, 'קצה': 195, 'קצו': 196, 'קצז': 197, 'קצח': 198, 'קצט': 199,
            'רא': 201 // וכן הלאה
        };

        function hebrewLetterToValue(letter) {
            return HEBREW_LETTERS_TO_NUMBER[letter] || 0;
        }

        function hebrewSectionToKey(hebrewSection) {
            if (HEBREW_LETTERS_TO_NUMBER[hebrewSection]) {
                return HEBREW_LETTERS_TO_NUMBER[hebrewSection];
            }
            let sum = 0;
            for (let i = 0; i < hebrewSection.length; i++) {
                sum += hebrewLetterToValue(hebrewSection[i]);
            }
            return sum;
        }
        
        function hasNikud(text) {
            return /[\u0591-\u05C7]/.test(text);
        }
        
        function parseMidotText(text) {
            // console.log("parseMidotText: Starting text processing. Text length:", text.length);
            const lines = text.split('\n');
            const parsedEntries = [];
            let currentTopicBase = "";
            let currentTopicForDisplay = "";
            let isPartTwoContext = false;
            let sectionTextBuffer = "";
            let currentLetter = "";
            
            let lineIndex = 0;
            let foundStart = false;

            for (let i = 0; i < lines.length - 2; i++) {
                if (lines[i].trim() === "________________" &&
                    lines[i+1].trim() === "אמת" && 
                    lines[i+2].trim() === "________________") {
                    lineIndex = i + 2; 
                    foundStart = true;
                    // console.log("parseMidotText: Found start of 'אמת'. Starting after its separator, from line index:", lineIndex);
                    break;
                }
            }

            if (!foundStart) {
                console.error("parseMidotText: Could not find the expected start (line / אמת / line). Check midottext_1.txt");
                return []; 
            }

            for (; lineIndex < lines.length; lineIndex++) {
                let line = lines[lineIndex].trim();

                if (line === "________________") {
                    if (currentLetter && sectionTextBuffer && currentTopicForDisplay) {
                        parsedEntries.push({ topic: currentTopicForDisplay, letter: currentLetter, text: sectionTextBuffer.trim() });
                        // console.log(`Saved section: ${currentTopicForDisplay} - ${currentLetter}`);
                        sectionTextBuffer = ""; 
                    }
                    // After a separator, we might find a new topic, or "חלק שני", or another section letter.
                    // The currentLetter should persist if it's another section of the same topic/part.
                    // It will be overwritten if a new section letter is found or reset if a new topic/part is found.
                    continue; 
                }
                if (line === "") continue;

                const nextLineIndex = lineIndex + 1 < lines.length ? lines[lineIndex+1].trim() : "";
                const nextNextLineIndex = lineIndex + 2 < lines.length ? lines[lineIndex+2].trim() : "";

                // Scenario 1: New Topic (קו -> נושא -> קו)
                // The current line is the topic name, previous was separator (implicit from loop or previous iteration), next is separator
                if (line !== "חלק שני" && 
                    !hasNikud(line) && 
                    line.split(/\s+/).length <= 5 && 
                    !line.match(/^([א-ת]{1,3})\.(?!\S)/) &&
                    nextLineTrimmed === "________________" &&
                    ( (lineIndex > 0 && lines[lineIndex-1].trim() === "________________") || (lineIndex > 1 && lines[lineIndex-1].trim() === "" && lines[lineIndex-2].trim() === "________________" ) )
                   ) {
                    
                    if (currentLetter && sectionTextBuffer && currentTopicForDisplay) { // Save previous section of previous topic
                        parsedEntries.push({ topic: currentTopicForDisplay, letter: currentLetter, text: sectionTextBuffer.trim() });
                         // console.log(`Saved section before new topic: ${currentTopicForDisplay} - ${currentLetter}`);
                    }
                    currentTopicBase = line;
                    currentTopicForDisplay = line;
                    isPartTwoContext = false;
                    currentLetter = ""; 
                    sectionTextBuffer = "";
                    console.log("parseMidotText: New Topic Identified:", currentTopicBase);
                    lineIndex++; // Consume the topic line and the separator line after it in the next iteration
                    continue;
                }
                
                // Scenario 2: "חלק שני" (קו -> חלק שני -> קו)
                if (line === "חלק שני" && currentTopicBase && 
                    ( (lineIndex > 0 && lines[lineIndex-1].trim() === "________________") || (lineIndex > 1 && lines[lineIndex-1].trim() === "" && lines[lineIndex-2].trim() === "________________" ) ) &&
                    nextLineTrimmed === "________________") {
                    
                    if (currentLetter && sectionTextBuffer && currentTopicForDisplay) { // Save previous section (from part 1)
                        parsedEntries.push({ topic: currentTopicForDisplay, letter: currentLetter, text: sectionTextBuffer.trim() });
                        // console.log(`Saved section before part two: ${currentTopicForDisplay} - ${currentLetter}`);
                    }
                    isPartTwoContext = true;
                    currentTopicForDisplay = currentTopicBase + " (חלק שני)";
                    currentLetter = "";
                    sectionTextBuffer = "";
                    console.log("parseMidotText: Activated Part Two for:", currentTopicBase, "Display Name:", currentTopicForDisplay);
                    lineIndex++; // Consume "חלק שני" and the separator line after it in the next iteration
                    continue;
                }

                // Scenario 3: Section letter and text
                const sectionMatch = line.match(/^([א-ת]{1,3})\.(?!\S)/);
                if (sectionMatch && !hasNikud(sectionMatch[1]) && currentTopicBase) { 
                    if (currentLetter && sectionTextBuffer && currentTopicForDisplay) { // Save previous section
                        parsedEntries.push({ topic: currentTopicForDisplay, letter: currentLetter, text: sectionTextBuffer.trim() });
                         // console.log(`Saved section: ${currentTopicForDisplay} - ${currentLetter}`);
                    }
                    currentLetter = sectionMatch[1];
                    sectionTextBuffer = line.substring(sectionMatch[0].length).trim();
                    
                    // Ensure currentTopicForDisplay is correctly set
                    if (isPartTwoContext) {
                        currentTopicForDisplay = currentTopicBase + " (חלק שני)";
                    } else {
                        currentTopicForDisplay = currentTopicBase;
                    }
                    // console.log(`parseMidotText: Section Start: ${currentTopicForDisplay} - ${currentLetter}, Text: "${sectionTextBuffer.substring(0,30)}"`);
                } else if (currentLetter && currentTopicForDisplay) { // Line is part of current section's text
                    sectionTextBuffer += (sectionTextBuffer ? " " : "") + line;
                } else {
                     // console.warn(`parseMidotText: Discarding or unhandled line ${lineIndex + 1}: "${line}" | currentTopicBase: ${currentTopicBase}`);
                }
            }

            if (currentLetter && sectionTextBuffer && currentTopicForDisplay) { // Save the very last section
                // console.log(`parseMidotText: Saving last section: ${currentTopicForDisplay} - ${currentLetter}`);
                parsedEntries.push({ topic: currentTopicForDisplay, letter: currentLetter, text: sectionTextBuffer.trim() });
            }

            if (parsedEntries.length === 0) {
                console.warn("parseMidotText: Processing finished, but no entries were created. Check input file structure and parsing logic.");
            } else {
                // console.log(`parseMidotText: Processing finished. Total entries created: ${parsedEntries.length}`);
            }
            
            const groupedByTopic = parsedEntries.reduce((acc, entry) => {
                if (!acc[entry.topic]) acc[entry.topic] = [];
                acc[entry.topic].push(entry);
                return acc;
            }, {});

            const sortedEntries = [];
            const topicOrderFromFile = [];
            parsedEntries.forEach(entry => {
                if (!topicOrderFromFile.includes(entry.topic)) {
                    topicOrderFromFile.push(entry.topic);
                }
            });

            for (const topicName of topicOrderFromFile) {
                if (groupedByTopic[topicName]) {
                    groupedByTopic[topicName].sort((a, b) => hebrewSectionToKey(a.letter) - hebrewSectionToKey(b.letter));
                    sortedEntries.push(...groupedByTopic[topicName]);
                }
            }
            return sortedEntries;
        }

        async function loadAndProcessEntries() {
            topicElement.textContent = "טוען נתונים..."; 
            letterElement.textContent = "";
            textElement.textContent = "";
            const url = 'https://raw.githubusercontent.com/NaNa-148/nanah148/main/midottext_1.txt';
            try {
                // console.log("loadAndProcessEntries: Starting fetch from URL:", url);
                const response = await fetch(url, { cache: "no-store" }); 
                // console.log("loadAndProcessEntries: Received response from server, status:", response.status);
                if (!response.ok) {
                    const errorText = await response.text(); 
                    console.error(`loadAndProcessEntries: HTTP error! status: ${response.status}`, `Response: ${errorText.substring(0,500)}...`);
                    throw new Error(`HTTP error! status: ${response.status}.`);
                }
                const text = await response.text();
                if (!text || text.trim() === "") {
                    console.error("loadAndProcessEntries: Data file is empty or contains only whitespace.");
                    throw new Error("קובץ הנתונים ריק.");
                }
                // console.log("loadAndProcessEntries: Text loaded successfully. Text length:", text.length, "Starting parsing...");
                const parsed = parseMidotText(text); 
                // console.log(`loadAndProcessEntries: Parsing finished. ${parsed.length} entries created.`);
                if(parsed.length === 0 && text.length > 0) {
                    console.warn("loadAndProcessEntries: Entry array is empty after parsing, although the file was not empty. Check parsing logic (parseMidotText) and file content/structure.");
                     topicElement.textContent = "עיבוד הנתונים הסתיים ללא תוצאות.";
                     textElement.textContent = "אנא בדוק את מבנה קובץ הנתונים וה-Console.";
                }
                return parsed;
            } catch (error) {
                console.error("loadAndProcessEntries: Error in function:", error);
                topicElement.textContent = "שגיאה בטעינת הנתונים";
                textElement.textContent = `אירעה שגיאה: ${error.message}. אנא בדוק את ה-Console (F12) לפרטים נוספים וודא שקובץ הנתונים ב-GitHub תקין ונגיש.`;
                return [];
            }
        }

        function populateTopicSelect() {
            const topics = new Set(entries.map(entry => entry.topic));
            const previouslySelectedTopicValue = topicSelectElement.value;

            while (topicSelectElement.options.length > 1) {
                topicSelectElement.remove(1);
            }
            let topicsArray = [];
            entries.forEach(entry => { 
                if (!topicsArray.includes(entry.topic)) {
                    topicsArray.push(entry.topic);
                }
            });

            topicsArray.forEach(topic => {
                const option = document.createElement('option');
                option.value = topic;
                option.textContent = topic;
                topicSelectElement.appendChild(option);
            });
            if (topicsArray.includes(previouslySelectedTopicValue)) {
                topicSelectElement.value = previouslySelectedTopicValue;
            } else {
                topicSelectElement.value = "all";
            }
        }

        function updateDisplay() {
            if (currentFilteredEntries.length === 0) {
                if (entries.length > 0 && currentSelectedTopic !== "all") {
                     topicElement.textContent = "אין משפטים לנושא: " + currentSelectedTopic;
                     letterElement.textContent = "";
                     textElement.textContent = "אנא בחר נושא אחר או 'כל הנושאים'.";
                } else if (entries.length === 0 && (topicElement.textContent === "טוען נתונים..." || topicElement.textContent.startsWith("שגיאה בטעינת") || topicElement.textContent.startsWith("עיבוד הנתונים הסתיים"))) {
                    // Keep loading/error/processing message
                } else {
                     topicElement.textContent = "לא נמצאו משפטים";
                     letterElement.textContent = "";
                     textElement.textContent = "";
                }
                return;
            }
            if (current >= currentFilteredEntries.length) { current = 0; }
            
            const entry = currentFilteredEntries[current];
            if (entry) {
                topicElement.style.opacity = 0;
                letterElement.style.opacity = 0;
                textElement.style.opacity = 0;
                setTimeout(() => {
                    topicElement.textContent = entry.topic;
                    letterElement.textContent = "סעיף " + entry.letter;
                    textElement.textContent = entry.text;
                    topicElement.style.opacity = 1;
                    letterElement.style.opacity = 1;
                    textElement.style.opacity = 1;
                }, 300);
            }
        }
        
        function handleTopicChange() {
            currentSelectedTopic = topicSelectElement.value;
            if (currentSelectedTopic === "all") {
                currentFilteredEntries = [...entries];
            } else {
                currentFilteredEntries = entries.filter(entry => entry.topic === currentSelectedTopic);
            }
            current = 0; 
            updateDisplay();
            resetInterval();
        }

        function nextSlide() {
            if (currentFilteredEntries.length === 0) return;
            if (isRandom) {
                let next = current;
                if (currentFilteredEntries.length > 1) {
                    do {
                        next = Math.floor(Math.random() * currentFilteredEntries.length);
                    } while (next === current);
                }
                current = next;
            } else {
                current = (current + 1) % currentFilteredEntries.length;
            }
            updateDisplay();
        }

        function prevSlide() {
            if (currentFilteredEntries.length === 0) return;
            current = (current - 1 + currentFilteredEntries.length) % currentFilteredEntries.length;
            updateDisplay();
        }

        function toggleRandom() {
            isRandom = !isRandom;
            randomToggleButton.textContent = isRandom ? "סדר: אקראי" : "סדר: רגיל";
        }

        function toggleFullScreen() {
            const elem = document.documentElement;
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.log("Fullscreen error:", err.message));
                } else if (elem.mozRequestFullScreen) { 
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) { 
                    elem.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                } else if (elem.msRequestFullscreen) { 
                    elem.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }
        
        function onFullscreenChange() {
            const isFullscreen = document.fullscreenElement || document.webkitIsFullScreen || document.mozFullScreenElement || document.msFullscreenElement;
            if (isFullscreen) {
                bodyElement.classList.add('fullscreen-active');
            } else {
                bodyElement.classList.remove('fullscreen-active');
            }
        }

        function updateInterval() {
            const select = document.getElementById("timing-select");
            duration = parseInt(select.value);
            resetInterval();
        }

        function resetInterval() {
            clearInterval(intervalId);
            if (currentFilteredEntries.length > 0) {
                 intervalId = setInterval(nextSlide, duration);
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            entries = await loadAndProcessEntries(); 

            if (entries.length > 0) {
                currentFilteredEntries = [...entries]; 
                populateTopicSelect();
                
                const initialDurationSelect = document.getElementById("timing-select");
                duration = parseInt(initialDurationSelect.value);

                updateDisplay(); 
                intervalId = setInterval(nextSlide, duration);
            } else {
                 // הודעת השגיאה כבר טופלה בתוך loadAndProcessEntries אם הטעינה נכשלה.
                 // אם הפארסינג החזיר 0 רשומות למרות שהקובץ אינו ריק, נציג הודעה אחרת.
                if (topicElement.textContent === "טוען נתונים...") { // אם הודעת הטעינה המקורית עדיין מוצגת
                     topicElement.textContent = "לא נוצרו רשומות מהקובץ.";
                     letterElement.textContent = "";
                     textElement.textContent = "אנא בדוק את מבנה הקובץ ואת ה-Console (F12) לפרטים נוספים.";
                }
            }

            document.getElementById('prev-btn').addEventListener('click', () => {
                prevSlide();
                resetInterval();
            });
            document.getElementById('next-btn').addEventListener('click', () => {
                nextSlide();
                resetInterval();
            });
            document.getElementById('random-toggle').addEventListener('click', toggleRandom);

            document.addEventListener('fullscreenchange', onFullscreenChange);
            document.addEventListener('webkitfullscreenchange', onFullscreenChange);
            document.addEventListener('mozfullscreenchange', onFullscreenChange);
            document.addEventListener('MSFullscreenChange', onFullscreenChange);
        });

    </script>
</body>
</html>
